'''
Author: MrDerpus

Version: 2.1.0 -A

Dev / compatibility conditions:
Fedora  38 Python 3.12.1
Windows 10 Python 3.12.2


[Very big update.]

+ Removed separate functions to change Syntax separator functions & have 
replaced them with the them with the '@set' function.

+ Changed the the start character for functions from '$' to '@'.
Variables will now use the '$' symbol at the prefix.

+ Added variables to the language, and the user can declare and use them
in scripts.  I plan on adding environment variables next.
You can declare ints and strings


x All @commands and tags require the syntax separator to take values.
This will be changed in the next couple of versions.

x The child element is unable to receive tag attributes as of yet.
This is a low priority fix.


? Variables can only be used in the text display as of now, this does not include
lists either.  I plan to update this so you can use variables anywhere within tags.

? I want to add more HTML tags.

? I want to clean and refactor code where it is needed.
Including better commenting.

? I want to update the github Readme.md description.

? I want to create a user manual for the language.
'''

from rich.traceback import install; install(show_locals = True)
from rich.console   import Console; c = Console()

from bs4 import BeautifulSoup

import click

import sys
import os

from settings import HASH, COMMENTS, SYNTAX, VALID


#Version program,
version = '2.1.0 -A'

# custom function to test if a string is wrapped in a specific char.
# remove for version 0.0.3 - never used.
# Lol it's still here in v2.0.2 -A.
def isWrapped(string:str, char:str='"'):
	if(string[0] and string[len(string)-1] != char):
		return False
	else:
		return True
	

# Custom error messages printed to the screen.
def ERROR(ERROR:str='', LINE:int = -9, DESCRIPTION:str = '', EXIT:bool = True, EXIT_CODE:int = 1, DISPLAY_TYPE:int = 0):
	if(DISPLAY_TYPE == 0): c.print(f' ERROR @ LINE: {LINE} \n {ERROR} \n {DESCRIPTION} \n')
	elif(DISPLAY_TYPE == 1): c.print(f' {ERROR}')

		
	if(EXIT == True): sys.exit(EXIT_CODE)


@click.group()
def cli(): pass




@click.command()
@click.option('--input_file',  '-i',  default = HASH.NO_INPUT_FILE)
@click.option('--output_file', '-o',  default = HASH.NO_OUTPUT_FILE)
@click.option('--formatter',   '-f',  default = False)
def build(input_file:str, output_file:str, formatter:bool):

	# Var declare 
	converted_line:str = '' # What gets output to user defined file.
	innerText:str = '' # Depending on the tag, this could be text or a file.
	tag_args:str  = '' # Tag arguments / attributes
	line_count:int = 1 # line number
	keyword:str = ''   # keyword that gets compared with various keyword lists.
	previous_keyword:str = ''
	user_variables:dict = {'dummy':12345}
	called_variable = None
	variable = None

	other_tag_Args:str = ''
	
	classInLine:bool = False
	idInLine:bool = False
	dic:dict = {}

	
	

	# If there where either no defined input or output files, display error and exit.
	if(input_file == HASH.NO_INPUT_FILE):
		ERROR('There was no input .SHTML file defined.', DISPLAY_TYPE=1, EXIT=True)

		#if(not os.path.exists(input_file)):
		#	ERROR(f'The script you defined \'{input_file}\' does not exist.', DISPLAY_TYPE=1, EXIT=True)


	elif(output_file == HASH.NO_OUTPUT_FILE):
		ERROR('There was no output .HTML file defined.', DISPLAY_TYPE=1, EXIT=True)

	
	# remove file, only for it to be created again.
	if(os.path.exists(output_file)):
		os.remove(output_file)



	# Output 
	c.print(f' Building output: {output_file} \n', style = '#00ffff')
	with open(output_file, 'a') as outfile:
		outfile.write(f'<!-- This HTML was generated by SHTML v{version} -->\n')




	# Read file line by line
	with open(input_file, 'r') as infile:

		
		for line in infile:
			line = line.lstrip().rstrip() # Cleanse line and grab keyword.


			

			# is line a comment?
			comment = len(line) >= 1
			if(comment and line[0] == COMMENTS.SINGLE_LINE_SCRIPT):  # comment for script itself.
				keyword = HASH.COMMENT
				converted_line = ''
			else:
				keyword = ''
			
			if(comment and line[0:2] == COMMENTS.SINGLE_LINE_HTML): # html comment.
				keyword = HASH.COMMENT
				innerText = line[2:].lstrip().rstrip()
			else:
				keyword = ''


			# Are class and id called in line?
			# If so, then grab string positions
			# and set bools to true. If not, set
			# bools to false. 
			if('.' in line.split(SYNTAX.SEPARATOR)[0]):
				dic['.'] = line.find('.')
				classInLine = True
			else:
				classInLine = False


			if('#' in line.split(SYNTAX.SEPARATOR)[0]):
				dic['#'] = line.find('#')
				idInLine = True
			else:
				idInLine = False


			# Grab keyword
			if(keyword != HASH.COMMENT):
				try:
					keyword = line[0:sorted(dic.values())[0]].lstrip().rstrip()
				except:
					keyword = line.split(SYNTAX.SEPARATOR)[0].lstrip().rstrip().lower()



			# Grab innerText
			try:
				innerText = line.split(SYNTAX.SEPARATOR)[1].lstrip().rstrip()
				if(SYNTAX.TAG_ATTRIBUTE in innerText): # is there a tag attribute seq in line?
					other_tag_Args += f'{innerText.split(SYNTAX.TAG_ATTRIBUTE)[1]}'
					innerText = innerText.split(SYNTAX.TAG_ATTRIBUTE)[0].lstrip().rstrip()

				if(SYNTAX.VARIABLE in innerText): # is there a variable being called
					variable = innerText.split(SYNTAX.VARIABLE)[1]
					called_variable = str(user_variables[variable])
					innerText = innerText.replace(f'{SYNTAX.VARIABLE}{variable}', called_variable)

			except Exception as err:
				#print(err)
				innerText = ''
				other_tag_Args = ''


			# Grab tag elements
			_line = line.replace(keyword, '').split(SYNTAX.SEPARATOR)[0].lstrip().rstrip()
			_line = _line.replace(' ', '')


			# double handle to make sure either in in the line.
			if classInLine: dic[SYNTAX.CLASS] = _line.find(SYNTAX.CLASS)

			if idInLine: dic[SYNTAX.ID] = _line.find(SYNTAX.ID)




			# If CLASS position value is less than the ID position value,
			# grab then grab CLASS value first and then ID value.
			# and Vice versa. This is purely for esthetics.
			if(classInLine and idInLine) == True: 
				if(dic[SYNTAX.CLASS] <= dic[SYNTAX.ID]):
					#print(_line.split('#'))
					idName = _line.split(SYNTAX.ID)[1]

					className = _line[1:dic[SYNTAX.ID]]
					tag_args = f'class="{className}" id="{idName}"'

				else:
					className = _line.split(SYNTAX.CLASS)[1]

					idName = _line[1:dic[SYNTAX.CLASS]]
					tag_args = f'id="{idName}" class="{className}"'

			# if only class
			elif(classInLine == True and idInLine == False):
				className = _line[1:]
				tag_args = f'class="{className}"'

			# if only id
			elif(idInLine == True and classInLine == False):
				idName = _line[1:]
				tag_args = f'id="{idName}"'

			# if None
			else:
				tag_args = f''

			tag_args = f'{tag_args} {other_tag_Args}'
			# ----------------------------


			# Output tags depending on the type as defined.
			if(keyword in VALID.HTML_SELF_CLOSING):
				converted_line = f'<{keyword} {tag_args}/>'


			elif(keyword in VALID.HTML_INTERVENTION):
				converted_line = f'<{keyword} {tag_args}>{innerText}</{keyword}>'

				if(SYNTAX.CLOSE in innerText): # closing tag
					innerText = innerText.replace(SYNTAX.CLOSE, '').lstrip().rstrip()
					#innerText += f'</{previous_keyword}>'

					converted_line = f'<{keyword} {tag_args}>{innerText}</{keyword}>\n</{previous_keyword}>'
				

			elif(keyword in VALID.HTML_NON_INTERVENTION):
				converted_line = f'<{keyword} {tag_args}>{innerText}'
				
				if(keyword == 'div'):
					previous_keyword = keyword


			elif(keyword in VALID.HTML_CUSTOM):
				custom = keyword

				# Is the line a list?
				if(custom == 'ol' or custom == 'ul'):
					child = line.split('>')[1]
					child = child.split(SYNTAX.SEPARATOR)[0]

					tag_args = tag_args.replace(f'>{child}', '').lstrip().rstrip()

					converted_line = f'<{custom} {tag_args}>\n'

					items = line.split(SYNTAX.SEPARATOR)[1:]
					for i in range(len(items)): # sanitise items, get rid of whitespace.
						items[i] = items[i].lstrip().rstrip()
						converted_line += f'<{child}>{items[i]}</{child}>\n'

					converted_line += f'</{custom}>'


				elif(custom == 'favicon'):
					custom = 'icon'

				match custom:
					case 'html':
						converted_line = '<!DOCTYPE html>\n<html>'
					
					case 'script':
						converted_line = f'<script src="{innerText}" {tag_args}></script>'
					
					case 'stylesheet':
						converted_line = f'<link rel="stylesheet" type="text/css" href="{innerText}" {tag_args} />'

					case 'icon':
						converted_line = f'<link rel="icon" type="image/x-icon" href="{innerText}" />'

					case 'body':
						converted_line = f'</head>\n<body {tag_args}>'


			elif(keyword[1:] in VALID.COMMANDS and keyword[0] == SYNTAX.FUNCTION):
				command = keyword[1:]
				converted_line = ''

				match command:
					case 'set':
						innerText = line.split()[2]
						if(innerText in VALID.SYNTAX):
							value = str(line.split()[3])
							VALID.SYNTAX[innerText] = value

							match innerText: 
								case 'SYNTAX.SEPARATOR':
									SYNTAX.SEPARATOR = value

								case 'SYNTAX.CLOSE':
									SYNTAX.CLOSE = value

								case 'SYNTAX.ID':
									SYNTAX.ID = value

								case 'SYNTAX.CLASS':
									SYNTAX.CLASS = value

								case 'SYNTAX.TAG_ATTRIBUTE':
									SYNTAX.TAG_ATTRIBUTE = value

								case 'SYNTAX.FUNCTION':
									SYNTAX.FUNCTION = value

								case 'SYNTAX.VARIABLE':
									SYNTAX.VARIABLE = value

								case 'SYNTAX.CHILD':
									SYNTAX.CHILD = value


					case 'var': # @var | string test = This is a test!
						line = line.replace('=', ' = ')
						line = line.replace('+', ' + ')
						line = line.replace('-', ' - ')
						variable_type  = line.split()[2]
						variable_name  = line.split()[3]
						operator = line.split()[4]
						variable_value = line.split()[5]

						
						match variable_type:
							case 'int':
								variable_value = int(variable_value)

							case 'string':
								variable_value = line.split('"')[1]
								variable_value = variable_value.replace('"', '')
								variable_value = str(variable_value)

						if(operator == '='):
							user_variables[variable_name] = variable_value
						
						if(variable_name in user_variables):
							match operator:
								case '+':
									user_variables[variable_name] += variable_value

								case '-':
									user_variables[variable_name] -= variable_value



						#c.print(user_variables)





					case 'inject':
						converted_line = innerText

					case 'exit':
						sys.exit(0)


			elif(keyword == HASH.COMMENT): # comment
				converted_line = f'<!-- {line[2:]} -->'


			else: # Some unknown error, or a blank space in document.
				if(len(keyword) > 0):
					ERROR(f'Unknown keyword or command \'{keyword}\'', line_count, 'The keyword you specified is invalid, please check you spelling.', False)
				converted_line = ''





			dic = {} # refresh dict for fresh new line draw.
			other_tag_Args = ''
			# Write to file
			if(len(converted_line) > 0):
				with open(output_file, 'a') as outfile:
					outfile.write(converted_line + '\n')



			# Increment by 1
			line_count += 1

		# At the end of executing the script, add closing body & html tags
		# automatically.
		with open(output_file, 'a') as outfile:
			outfile.write('</body>\n</html>')
			
		



		# Beautiful Soup 4 HTML file formatter.
		if(formatter == True):
			c.print(' Formatting HTML file . . .', style = '#00ffff')
			# Read the HTML file
			with open(output_file, 'r') as f:
				html_content = f.read()

			# Write the pretty HTML content back to the file
			with open(output_file, 'w') as f:
				f.write(BeautifulSoup(html_content, 'html.parser').prettify(formatter = 'html'))




# Add command, and run command.
cli.add_command(build)


if(__name__ == '__main__'):
	cli()