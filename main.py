'''
Author: MrDerpus


Version: 2.0.0 -A

EMMET LIKE SYNTAX TEST


Dev conditions:
Windows 10 / Fedora 38
Python 3.12.2


Tested Compatible OS's:
Windows 10
Fedora  38


Description: 
Simple HTML (SHTML).


'''

from rich.traceback import install; install(show_locals = True) # type: ignore
from rich.console   import Console; c = Console() # type: ignore

import click # type: ignore

import sys
import os

from settings import HASH, COMMENTS, SYNTAX, VALID


#Version program,
version = '2.0.0 -A'

# custom function to test if a string is wrapped in a specific char.
# remove for version 0.0.3 - never used.
def isWrapped(string:str, char:str='"'):
	if(string[0] and string[len(string)-1] != char):
		return False
	else:
		return True
	

# Custom error messages printed to the screen.
def ERROR(ERROR:str='EMPTY STRING', LINE:int = -999, DESCRIPTION:str = 'EMPTY STRING', EXIT:bool = True, EXIT_CODE:int = 1, DISPLAY_TYPE:int = 0):
	if(DISPLAY_TYPE == 0): c.print(f' ERROR @ LINE: {LINE} \n {ERROR} \n {DESCRIPTION} \n')
	elif(DISPLAY_TYPE == 1): c.print(f' {ERROR}')

		
	if(EXIT == True): sys.exit(EXIT_CODE)


@click.group()
def cli(): pass




@click.command()
@click.option('--input_file',   '-i',  default = HASH.NO_INPUT_FILE)
@click.option('--output_file',  '-o',  default = HASH.NO_OUTPUT_FILE)
def build(input_file:str, output_file:str):

	# Var declare 
	converted_line:str = '' # What gets output to user defined file.
	innerText:str = '' # 
	tag_args:str  = ''
	line_count:int = 1
	keyword:str = ''
	previous_keyword:str = ''
	
	classInLine:bool = False
	idInLine:bool = False
	dic:dict = {}

	
	

	# If there where either no defined input or output files, display error and exit.
	if(input_file == HASH.NO_INPUT_FILE):
		ERROR('There was no input .SHTML file defined.', DISPLAY_TYPE=1, EXIT=True)

		#if(not os.path.exists(input_file)):
		#	ERROR(f'The script you defined \'{input_file}\' does not exist.', DISPLAY_TYPE=1, EXIT=True)


	elif(output_file == HASH.NO_OUTPUT_FILE):
		ERROR('There was no output .HTML file defined.', DISPLAY_TYPE=1, EXIT=True)

	
	# remove file, only for it to be created again.
	if(os.path.exists(output_file)):
		os.remove(output_file)



	# Output 
	c.print(f' Building output: {output_file} \n', style = '#00ffff')
	with open(output_file, 'a') as outfile:
		outfile.write(f'<!-- This HTML was generated by SHTML v{version} -->\n')




	# Read file line by line
	with open(input_file, 'r') as infile:

		
		for line in infile:
			line = line.lstrip().rstrip() # Cleanse line and grab keyword.


			

			# is line a comment?
			comment = len(line) >= 1
			if(comment and line[0] == COMMENTS.SINGLE_LINE_SCRIPT):  # comment for script itself.
				keyword = HASH.COMMENT
				converted_line = ''
			
			if(comment and line[0:2] == COMMENTS.SINGLE_LINE_HTML): # html comment.
				keyword = HASH.COMMENT
				innerText = line[2:].lstrip().rstrip()
				

			# if line is blank, set line to be ignored
			if(len(line) <= 0): keyword = HASH.IGNORE


			# Error: unrecognised keyword / command
			if(keyword != HASH.COMMENT and keyword != HASH.IGNORE): # WHY DOES 'OR' NOT WORK??????
				if(keyword not in VALID.VALID):
					ERROR(f'Unknown keyword or command \'{keyword}\'', line_count, 'The keyword you specified is invalid, please check you spelling.', False)



			# ---

			# Are class and id called in line?
			# If so, then grab strong positions
			# and set bools to true. If not, set
			# bools to false. 
			if '.' in line.split('|')[0]:
				dic['.'] = line.find('.')
				classInLine = True
			else:
				classInLine = False


			if '#' in line.split('|')[0]:
				dic['#'] = line.find('#')
				idInLine = True
			else:
				idInLine = False
			


			# Grab keyword
			try:
				keyword = line[0:sorted(dic.values())[0]].lstrip().rstrip()
			except:
				keyword = line.split('|')[0].lstrip().rstrip()



			# Grab InnerText
			try:
				innerText = line.split('|')[1].lstrip().rstrip()
			except:
				innerText = ''


			# Grab tag elements
			tagArguments = line.replace(keyword, '').split('|')[0].lstrip().rstrip()
			tagArguments = tagArguments.replace(' ', '')
			#print(tagArguments)


			# duble handle to make sure either in in the line.
			if classInLine: dic['.'] = tagArguments.find('.')

			if idInLine: dic['#'] = tagArguments.find('#')




			# If CLASS position value is less than the ID positsion value,
			# grab then grab CLASS value first and then ID value.
			# and Vice versa. This is purely for esthetics.
			if classInLine and idInLine == True: 
				if(dic['.'] <= dic['#']):
					#print(tagArguments.split('#'))
					idName = tagArguments.split('#')[1]
					c.print(dic.values())

					className = tagArguments[1:dic['#']]
					_tagArguments = f'class="{className}" id="{idName}"'

				else:
					className = tagArguments.split('.')[1]
					c.print(dic.values())

					idName = tagArguments[1:dic['.']]
					_tagArguments = f'id="{idName}" class="{className}"'

			# if only class
			elif classInLine == True:
				className = tagArguments[1:]
				_tagArguments = f'class="{className}"'

			# if only id
			elif idInLine == True:
				idName = tagArguments[1:]
				_tagArguments = f'id="{idName}"'

			# if None
			else:
				_tagArguments = f''


			# @@@@@@@@ ^^^


			# Output tags depending on the type as defined.
			if(keyword in VALID.HTML_SELF_CLOSING):
				converted_line = f'<{keyword} {tag_args}/>'


			elif(keyword in VALID.HTML_INTERVENTION):
				
				if(SYNTAX.CLOSE in tag_args): # closing tag
					tag_args = tag_args.replace(SYNTAX.CLOSE, '')
					innerText += f'</{previous_keyword}>'

				converted_line = f'<{keyword} {tag_args}>{innerText}</{keyword}>'
				

			elif(keyword in VALID.HTML_NON_INTERVENTION):
				converted_line = f'<{keyword} {tag_args}>{innerText}'
				
				if(keyword == 'div'):
					previous_keyword = keyword






			# h1.className#idName%style="color:#f00;"|Hello World
			# <h1 class="className" id="idName" style="color:#f00;">Hello World</h1>

			# ul #idName > li .className * 5 | 1 | 2 | 3 | 4 | 5 | 6
			# <ul id="idName">
			# 	<li class="className">1</li>
			#  	<li class="className">2</li>
			#  	<li class="className">3</li>
			#  	<li class="className">4</li>
			#  	<li class="className">5</li>
			# </ul>


			# ---



			# Write to file
			if(len(converted_line) > 0):
				with open(output_file, 'a') as outfile:
					outfile.write(converted_line + '\n')



			# Increment by 1
			line_count += 1

		# At the end of executing the script, add closing body & html tags
		# automatically.
		with open(output_file, 'a') as outfile:
			outfile.write('</body>\n</html>')
			
			



# Add command, and run command.
cli.add_command(build)


if __name__ == '__main__':
	cli()
