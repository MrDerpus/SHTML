'''
Author: MrDerpus

Version: 2.2.0 -A

Dev / compatibility conditions:
Fedora  38 Python 3.12.1
Windows 10 Python 3.12.2
'''

from rich.traceback import install; install(show_locals = True) # type: ignore
from rich.console   import Console; c = Console() # type: ignore

from bs4 import BeautifulSoup # type: ignore

import click # type: ignore

import sys
import os

from settings import HASH, COMMENTS, SYNTAX, VALID


#Version program,
version = '2.2.0 -A'

# custom function to test if a string is wrapped in a specific char.
# remove for version 0.0.3 - never used.
# Lol it's still here in v2.1.1 -A.
def isWrapped(string:str, char:str='"'):
	if(string[0] and string[len(string)-1] != char):
		return False
	else:
		return True
	

# Custom error messages printed to the screen.
def ERROR(ERROR:str='', LINE:int = -9, DESCRIPTION:str = '', EXIT:bool = True, EXIT_CODE:int = 1, DISPLAY_TYPE:int = 0):
	if(DISPLAY_TYPE == 0): c.print(f' ERROR @ LINE: {LINE} \n {ERROR} \n {DESCRIPTION} \n')
	elif(DISPLAY_TYPE == 1): c.print(f' {ERROR}')

		
	if(EXIT == True): sys.exit(EXIT_CODE)


@click.group()
def cli(): pass




@click.command()
@click.option('--input_file',  '-i',  default = HASH.NO_INPUT_FILE)
@click.option('--output_file', '-o',  default = HASH.NO_OUTPUT_FILE)
@click.option('--formatter',   '-f',  default = False)
def build(input_file:str, output_file:str, formatter:bool):

	# Var declare 
	converted_line:str = '' # What gets output to user defined file.
	innerText:str = '' # Depending on the tag, this could be text or a file.
	tag_args:str  = '' # Tag arguments / attributes
	other_tag_Args:str = '' # only used for the '~%' separator keyword.
	line_count:int = 1 # Line number
	keyword:str = ''   # Gets compared with various keyword lists.
	previous_keyword:str = '' # 

	# comments
	comment:dict = {'type': 0, 'chars':''} # 0: No comment, 1: HTML comment, 2: Script comment

	# Variable data, name of, type of, value of, operator assigned to & called.
	variable = {'name': '', 'type': '', 'value': '', 'operator': '', 'called': ''}
	user_variables:dict = {} # All user defined variables are stored here.
	
	# This is all to be refactored, at some point.  Eventually.
	classInLine:bool = False # Is CLASS being defined?
	idInLine:bool = False # Is ID being defined?
	idName:str = '' # What is the name of your id?
	className:str = '' # What is the name of your class?
	dic:dict = {} # Only holds positional ints for CLASS and ID separator characters.

	
	

	# If there where either no defined input or output files, display error and exit.
	if(input_file == HASH.NO_INPUT_FILE):
		ERROR('There was no input .SHTML file defined.', DISPLAY_TYPE=1, EXIT=True)

		#if(not os.path.exists(input_file)):
		#	ERROR(f'The script you defined \'{input_file}\' does not exist.', DISPLAY_TYPE=1, EXIT=True)


	elif(output_file == HASH.NO_OUTPUT_FILE):
		ERROR('There was no output .HTML file defined.', DISPLAY_TYPE=1, EXIT=True)

	
	# remove file, only for it to be created again.
	if(os.path.exists(output_file)):
		os.remove(output_file)



	# Output 
	c.print(f' Building output: {output_file} \n', style = '#00ffff')
	with open(output_file, 'a') as outfile:
		outfile.write(f'<!-- This HTML was generated by SHTML v{version} -->\n')




	# Read file line by line
	with open(input_file, 'r') as infile:

		
		for line in infile:
			line = line.strip() # Cleanse line and grab keyword.

			# is line a comment?
			#is_comment = len(line) >= 1 # return True or False.
			comment['chars'] = line[0:2]
			if(comment['chars'] == COMMENTS.SINGLE_LINE_SCRIPT):  # comment for script itself.
				keyword = HASH.COMMENT
				comment['type'] = 2
				converted_line = ''
				innerText = ''
			
			elif(comment['chars'] == COMMENTS.SINGLE_LINE_HTML): # html comment.
				keyword = HASH.COMMENT
				comment['type'] = int(1)
				innerText = line[2:].strip()
			else:
				keyword = ''

			#print(line[0:2], end = ' ')
			#print(comment)
			# Are class and id called in line?
			# If so, then grab string positions
			# and set bools to true. If not, set
			# bools to false. 
			if(SYNTAX.CLASS in line.split(SYNTAX.SEPARATOR)[0]):
				dic[SYNTAX.CLASS] = line.find(SYNTAX.CLASS)
				classInLine = True
			else:
				classInLine = False


			if(SYNTAX.ID in line.split(SYNTAX.SEPARATOR)[0]):
				dic[SYNTAX.ID] = line.find(SYNTAX.ID)
				idInLine = True
			else:
				idInLine = False



			#########################
			# Grab keyword.
			# If the line isn't commented out, grab the keyword. 
			#########################
			if(keyword != HASH.COMMENT):
				try:
					keyword = line[0:sorted(dic.values())[0]].strip()
				except:
					keyword = line.split(SYNTAX.SEPARATOR)[0].strip().lower()



			#########################
			# Grab innerText.
			# <h1>INNERTEXT GOES HERE</h1>
   			#########################
			try:
				innerText = line.split(SYNTAX.SEPARATOR)[1].strip()
				
				if('/n' in innerText): # New line in elements
					innerText = innerText.replace('/n', '<br>')
				
				
				if(SYNTAX.TAG_ATTRIBUTE in innerText): # is there a tag attribute seq in line?
					other_tag_Args += f'{innerText.split(SYNTAX.TAG_ATTRIBUTE)[1]}'
					innerText = innerText.split(SYNTAX.TAG_ATTRIBUTE)[0].strip()

				if(SYNTAX.VARIABLE in innerText): # is there a variable being called
					variable['name'] = innerText.split(SYNTAX.VARIABLE)[1].split()[0]
					variable['called'] = user_variables[variable['name']]
					
					innerText =\
					innerText.replace(f'{SYNTAX.VARIABLE}{variable["name"]}',
					str(variable['called']))

				#if(SYNTAX.CLOSE in innerText): # closing tag
				#	innerText = innerText.replace(SYNTAX.CLOSE, '').strip()

			except Exception as err:
				#print(err)
				innerText = ''
				other_tag_Args = ''


			# Grab tag elements
			_line = line.replace(keyword, '').split(SYNTAX.SEPARATOR)[0].strip()
			_line = _line.replace(' ', '')


			# double handle to make sure either in in the line.
			if(classInLine):
				dic[SYNTAX.CLASS] = _line.find(SYNTAX.CLASS)

			if(idInLine):
				dic[SYNTAX.ID] = _line.find(SYNTAX.ID)



			# If CLASS position value is less than the ID position value,
			# grab then grab CLASS value first and then ID value.
			# and Vice versa. This is purely for esthetics.
			if(classInLine and idInLine == True): 
				if(dic[SYNTAX.CLASS] <= dic[SYNTAX.ID]):
					idName = _line.split(SYNTAX.ID)[1]

					className = _line[1:dic[SYNTAX.ID]]
					tag_args = f'class="{className}" id="{idName}"'

				else:
					className = _line.split(SYNTAX.CLASS)[1]

					idName = _line[1:dic[SYNTAX.CLASS]]
					tag_args = f'id="{idName}" class="{className}"'

			# if only class
			elif(classInLine == True and idInLine == False):
				className = _line[1:]
				tag_args = f'class="{className}"'

			# if only id
			elif(idInLine == True and classInLine == False):
				idName = _line[1:]
				tag_args = f'id="{idName}"'

			# if None
			else:
				tag_args = f''

			tag_args = f'{tag_args} {other_tag_Args}'
			# ----------------------------


			# Output tags depending on the type as defined.
			if(keyword in VALID.HTML_SELF_CLOSING):

				#innerText = innerText.replace(' ' , '')
				#innerText = innerText.strip()

				if(keyword == 'img'):
					converted_line = f'<{keyword} {tag_args} src="{innerText}" />'
				else:
					converted_line = f'<{keyword} {tag_args}/>'

				if(SYNTAX.CLOSE in converted_line):
					converted_line = converted_line.replace(SYNTAX.CLOSE, '')
					converted_line += f'\n</{previous_keyword}>'

				

			# I HAVE BROKEN ANCHOR TAGS!!!
			elif(keyword in VALID.HTML_INTERVENTION):
				#if(keyword == 'a'):
				#	converted_line = f'<{keyword} {tag_args} href="{innerText.split(SYNTAX.SEPARATOR)[0].split(SYNTAX.TAG_ATTRIBUTE)[1]}"></{keyword}>'
				#else:
				converted_line = f'<{keyword} {tag_args}>{innerText}</{keyword}>'

				if(SYNTAX.CLOSE in innerText): # closing tag
					innerText = innerText.replace(SYNTAX.CLOSE, '').strip()
					#innerText += f'</{previous_keyword}>'

					converted_line = f'<{keyword} {tag_args}>{innerText}</{keyword}>\n</{previous_keyword}>'
				

			elif(keyword in VALID.HTML_NON_INTERVENTION):
				converted_line = f'<{keyword} {tag_args}>{innerText}'
				
				if(keyword == 'div'):
					previous_keyword = keyword


			elif(keyword in VALID.HTML_CUSTOM):
				custom = keyword

				# Is the line a list?
				if(custom == 'ol' or custom == 'ul'):
					child = line.split(SYNTAX.CHILD)[1].strip()
					child = child.split(SYNTAX.SEPARATOR)[0].strip()

					tag_args = tag_args.replace(f'>{child}', '').strip()

					converted_line = f'<{custom} {tag_args}>\n'

					items = line.split(SYNTAX.SEPARATOR)[1:]
					for i in range(len(items)): # sanitise items, get rid of whitespace, check for vars.
						items[i] = items[i].strip()
		

						#get variables from line
						filter_list:list = items[i].split() 
						for x in range(len(filter_list)):
							if(filter_list[x][0] == SYNTAX.VARIABLE):
								filter_list[x] = filter_list[x][1:]
								#c.print(filter_list[x])
						#c.print(line_count)
						# ^^^ This code above does nothing but print ot the screen

						
						
					#Items is being turned from the KEY to VALUE
					

						# Are there variables in the list?
						# This is a mess and need's refactoring.
						if(items[i][1:] in user_variables):
							#__variable = items[i][1]

							items[i] =\
							items[i].replace(f'{SYNTAX.VARIABLE}{items[i][1]}',
							str({user_variables[items[i][1]]})).strip()
							
							converted_line += f'<{child}>{str(items[i][1])}</{child}>\n'
						else:
							converted_line += f'<{child}>{items[i]}</{child}>\n'
							#print(items[i])


					converted_line += f'</{custom}>'


				elif(custom == 'favicon'):
					custom = 'icon'

				match custom:
					case 'html':
						converted_line = '<!DOCTYPE html>\n<html>'
					
					case 'script':
						converted_line = f'<script src="{innerText}" {tag_args}></script>'
					
					case 'stylesheet':
						converted_line = f'<link rel="stylesheet" type="text/css" href="{innerText}" {tag_args} />'

					case 'icon':
						converted_line = f'<link rel="icon" type="image/x-icon" href="{innerText}" />'

					case 'body':
						converted_line = f'</head>\n<body {tag_args}>'


			elif(keyword[1:] in VALID.COMMANDS and keyword[0] == SYNTAX.FUNCTION):
				command = keyword[1:]
				converted_line = ''

				match command:
					case 'set':
						innerText = line.split()[2]
						if(innerText in VALID.SYNTAX):
							value = str(line.split()[3])
							VALID.SYNTAX[innerText] = value

							match innerText: 
								case 'SYNTAX.SEPARATOR':
									SYNTAX.SEPARATOR = value

								case 'SYNTAX.CLOSE':
									SYNTAX.CLOSE = value

								case 'SYNTAX.ID':
									SYNTAX.ID = value

								case 'SYNTAX.CLASS':
									SYNTAX.CLASS = value

								case 'SYNTAX.TAG_ATTRIBUTE':
									SYNTAX.TAG_ATTRIBUTE = value

								case 'SYNTAX.FUNCTION':
									SYNTAX.FUNCTION = value

								case 'SYNTAX.VARIABLE':
									SYNTAX.VARIABLE = value

								case 'SYNTAX.CHILD':
									SYNTAX.CHILD = value


					case 'var': # @var | string test = This is a test!
						line = line.replace('=', ' = ').replace('+', ' + ').replace('-', ' - ')
						variable['type']  = line.split()[2]
						variable['name']  = line.split()[3]
						variable['operator'] = line.split()[4]
						variable['value'] = line.split()[5]
						
						match str(f"{variable['type']}"):
							case 'int':
								variable['value'] = int(variable['value'])

							case 'string':
								variable['value'] = line.split('"')[1].replace('"', '')
								variable['value'] = str(variable['value'])

						if(variable['operator'] == '='):
							user_variables[variable['name']] = variable['value']
						
						if(variable['name'] in user_variables):
							match variable['operator']:
								case '+':
									user_variables[variable['name']] += variable['value']


								case '-':
									user_variables[variable['name']] -= variable['value']


					case 'inject':
						converted_line = innerText

					case 'exit':
						sys.exit(0)


			elif(keyword == HASH.COMMENT): # comment
				if(comment['type'] == 1):
					converted_line = f'<!-- {line[2:]} -->'


			else: # Some unknown error, or a blank space in document.
				if(len(keyword) > 0):
					ERROR(f'Unknown keyword or command \'{keyword}\'', line_count, 'The keyword you specified is invalid, please check your spelling.', False)
				converted_line = ''





			dic = {} # refresh dict for fresh new line draw.
			comment['type'] = 0
			comment['chars'] = ''
			other_tag_Args = ''
			# Write to file
			if(len(converted_line) > 0):
				with open(output_file, 'a') as outfile:
					outfile.write(converted_line + '\n')



			# Increment by 1
			line_count += 1

		# At the end of executing the script, add closing body & html tags
		# automatically.
		with open(output_file, 'a') as outfile:
			outfile.write('</body>\n</html>')
		#c.print(user_variables)
			
		



		# Beautiful Soup 4 HTML file formatter.
		if(formatter == True):
			c.print(' Formatting HTML file . . .', style = '#00ffff')
			# Read the HTML file
			with open(output_file, 'r') as f:
				html_content = f.read()

			# Write the pretty HTML content back to the file
			with open(output_file, 'w') as f:
				f.write(BeautifulSoup(html_content, 'html.parser').prettify(formatter = 'html'))



# Add command, and run command.
cli.add_command(build)


if(__name__ == '__main__'):
	cli()